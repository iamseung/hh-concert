# 시나리오 5: 지속적 부하 테스트 결과

**테스트 일시**: 2026-01-06
**테스트 조건**: 50 req/sec, 2분 지속 (테스트용 축소)
**원래 목표**: 1,000 req/sec, 10분

---

## 테스트 개요

### 목적
- 장시간 운영 시 시스템 안정성 확인
- 리소스 누수 및 메모리 관리 검증
- 대기열 → 예약 → 결제의 완전한 E2E 사용자 여정 측정

### 테스트 설정
- **부하**: 50 req/sec (constant-arrival-rate)
- **테스트 시간**: 2분
- **VUs**: 50 (pre-allocated) ~ 100 (max)
- **시나리오**: 완전한 사용자 여정 (토큰 발급 → 대기열 대기 → 콘서트 정보 조회 → 포인트 충전 → 좌석 예약 → 결제 → 예약 확인)

---

## 주요 결과

### ✅ 우수한 성능

| 지표 | 결과 | 평가 |
|------|------|------|
| HTTP 요청 성공률 | **100%** | ✅ 완벽 |
| 총 HTTP 요청 수 | **11,176건** | - |
| HTTP 처리량 | **84.33 req/sec** | ✅ 양호 |
| 평균 응답 시간 | **4.49ms** | ✅ 매우 빠름 |
| P95 응답 시간 | **6.82ms** | ✅ 우수 |
| P99 응답 시간 | - | - |
| Max 응답 시간 | **101.08ms** | ✅ 양호 |
| HTTP 실패율 | **0%** | ✅ 완벽 |

### ❌ 차단 이슈

| 지표 | 결과 | 평가 |
|------|------|------|
| 완료된 사용자 여정 | **1,016건** | - |
| 전체 성공률 | **0%** | ❌ 실패 |
| 에러율 | **100%** | ❌ 실패 |
| 대기열 에러 | **1,016건** (전체) | ❌ 차단 |
| 드롭된 요청 | **4,985건** | ⚠️ VU 부족 |

---

## 상세 메트릭

### HTTP 성능
```
총 HTTP 요청: 11,176건
처리량: 84.33 req/sec

응답 시간:
  - 평균: 4.49ms
  - 최소: 1.74ms
  - 최대: 101.08ms
  - 중앙값: 4.15ms
  - P90: 5.87ms
  - P95: 6.82ms

HTTP 요청 실패율: 0.00% ✅
```

### End-to-End 사용자 여정
```
완료된 여정: 1,016건
성공한 여정: 0건 (0%)
실패한 여정: 1,016건 (100%)

E2E 소요 시간:
  - 평균: 10,056ms (~10초)
  - 최소: 10,034ms
  - 최대: 10,188ms
  - P95: 10,077ms

실패 원인:
  - 대기열 활성화 타임아웃: 1,016건 (100%)
```

### 시스템 리소스
```
VUs:
  - 최소: 3
  - 최대: 100 (한계 도달)
  - 시작: 50 (pre-allocated)

메모리 사용량 (추정):
  - 평균: 12.5 MB
  - 최소: 0.5 MB
  - 최대: 50 MB (100 VUs)

Active Connections:
  - 평균: 25
  - 최대: 100
```

### 처리량 및 드롭율
```
목표 처리량: 50 iterations/sec
실제 완료: 7.67 iterations/sec

총 시도: 6,001 iterations
완료: 1,016 iterations
드롭: 4,985 iterations (83.07%)

드롭 원인:
  - VU 부족 (maxVUs=100 한계 도달)
  - 각 iteration이 ~12초 소요로 인한 VU 점유
```

---

## 발견된 이슈

### ❌ Critical: 대기열 활성화 타임아웃 (시나리오 1, 2, 3과 동일)

**현상**:
- 모든 사용자 여정이 대기열 활성화 단계에서 실패
- 1,016건의 토큰 발급 성공 → 0건의 ACTIVE 상태 전환
- `waitForQueueActivation()` 함수에서 10회 재시도 후 타임아웃

**원인**:
- 대기열 스케줄러가 WAITING → ACTIVE 상태 전환을 수행하지 않음
- `@Scheduled` 작업 미실행 또는 Redis 작업 실패로 추정

**영향**:
- **E2E 사용자 여정 테스트 불가**
- 예약, 결제 단계 완전 미측정
- 리소스 누수 및 장기 안정성 검증 불가

**재현성**:
- 시나리오 1, 2, 3, 5 모두 동일 이슈
- 시스템 설계 문제 또는 환경 설정 문제로 확인됨

---

### ⚠️ VU 부족으로 인한 높은 드롭율 (83%)

**현상**:
```
level=warning msg="Insufficient VUs, reached 100 active VUs and cannot initialize more"
```

**원인**:
- 각 iteration이 평균 12초 소요 (대기열 대기 10초 포함)
- 50 req/sec 목표 유지를 위해 600 VUs 필요 (50 * 12초)
- 실제 maxVUs는 100으로 설정되어 부족

**해결 방안**:
1. 대기열 활성화 이슈 해결 후 재측정 (iteration 시간 단축 예상)
2. maxVUs를 500~1000으로 증가
3. 또는 목표 처리량을 8~10 req/sec로 조정

---

## 측정 가능했던 성능

### 1. API 응답 성능

**결과**:
- 평균 응답 시간: **4.49ms**
- P95 응답 시간: **6.82ms**
- HTTP 성공률: **100%**

**분석**:
- 개별 API 엔드포인트는 매우 안정적
- 응답 속도는 목표(P95 < 500ms) 대비 **98.6% 개선**
- 시스템 크래시 없음

### 2. 토큰 발급 성능

**결과**:
- 총 1,016건 토큰 발급 성공
- 100% 성공률
- 평균 응답 시간: ~4ms (추정)

**분석**:
- 토큰 발급 API는 안정적으로 작동
- Redis ZADD 연산 정상

### 3. 시스템 안정성

**결과**:
- 2분간 지속 부하 유지
- 애플리케이션 크래시 없음
- 메모리 사용량 안정적 (최대 50MB for 100 VUs)

**분석**:
- 짧은 테스트 기간이지만 시스템 기본 안정성 확인
- 메모리 누수 징후 없음 (테스트 기간 한정)

---

## 측정하지 못한 항목

이 테스트는 다음 항목을 **측정하지 못했습니다**:

- ❌ 대기열 활성화 성능
- ❌ 콘서트 정보 조회 성능
- ❌ 포인트 충전 성능
- ❌ 좌석 예약 성능
- ❌ 결제 처리 성능
- ❌ 예약 확인 성능
- ❌ 장기간 운영 시 리소스 누수
- ❌ 10분 지속 부하 시 안정성
- ❌ E2E 사용자 여정 응답 시간

**원인**: 대기열 활성화 차단 이슈로 첫 단계 이후 진행 불가

---

## 성능 평가

### ✅ 양호한 부분

1. **API 응답 속도**: P95 6.82ms (목표 대비 98.6% 개선)
2. **HTTP 안정성**: 0% 실패율, 11,176건 모두 성공
3. **토큰 발급**: 100% 성공 (1,016건)
4. **시스템 안정성**: 크래시 없음, 메모리 안정적

### ❌ 개선 필요

1. **대기열 활성화 로직**: CRITICAL - 즉시 수정 필요
2. **VU 설정**: maxVUs를 500~1000으로 증가 필요
3. **테스트 재실행**: 활성화 이슈 해결 후 전체 재측정

---

## 비교: 목표 vs 실제

| 지표 | 목표 | 실제 | 상태 |
|------|------|------|------|
| 부하 | 1,000 req/sec | 50 req/sec | ⏸️ 테스트용 축소 |
| 테스트 시간 | 10분 | 2분 | ⏸️ 테스트용 축소 |
| P95 응답시간 | < 500ms | **6.82ms** | ✅ 우수 (98.6% 개선) |
| P99 응답시간 | < 1000ms | - | ⏸️ 미측정 |
| HTTP 실패율 | < 0.1% | **0%** | ✅ 완벽 |
| E2E 성공률 | > 99.9% | **0%** | ❌ 차단 이슈 |
| 에러율 | < 0.1% | **100%** | ❌ 차단 이슈 |

---

## 권장 사항

### 즉시 조치 (High Priority)

1. **대기열 활성화 스케줄러 점검**
   - `@Scheduled` 작업 실행 여부 확인
   - 로그 분석: 스케줄러 실행, 상태 전환 이벤트
   - Redis 연산 검증 (ZRANGEBYSCORE, ZADD 등)

2. **스케줄러 로직 디버깅**
   ```kotlin
   // QueueScheduler.kt 또는 유사 파일
   @Scheduled(fixedDelay = 1000) // 1초마다 실행?
   fun activateWaitingTokens() {
     // 로그 추가
     log.info("Scheduler executed: activating waiting tokens")
     // 상태 전환 로직 확인
   }
   ```

3. **환경 설정 확인**
   - Spring Boot 스케줄러 활성화 확인: `@EnableScheduling`
   - Redis 연결 상태 확인
   - 타임존 및 시간 동기화 확인

### 후속 테스트 (이슈 해결 후)

1. **시나리오 5 재실행**
   - 대기열 활성화 이슈 해결 후
   - maxVUs를 500~1000으로 증가
   - 전체 E2E 여정 측정

2. **점진적 부하 증가**
   - 50 req/sec → 100 req/sec → 500 req/sec → 1,000 req/sec
   - 각 단계에서 10분간 지속 부하 유지
   - 리소스 누수 및 성능 저하 모니터링

3. **측정 항목**
   - [ ] E2E 사용자 여정 성공률
   - [ ] 대기열 활성화 성능
   - [ ] 예약 및 결제 처리 성능
   - [ ] 장기간 운영 시 메모리 사용량 추이
   - [ ] DB 커넥션 풀 사용률
   - [ ] Redis 메모리 사용량

---

## 결론

### 측정된 성능
- **API 응답 속도**: 우수 (P95 6.82ms)
- **HTTP 안정성**: 완벽 (0% 실패율)
- **토큰 발급**: 안정적 (100% 성공)

### 차단 이슈
- **대기열 활성화 타임아웃**: CRITICAL - 모든 사용자 여정 실패
- E2E 테스트 불가로 핵심 목표 미달성

### 다음 단계
1. **즉시**: 대기열 스케줄러 로직 점검 및 수정
2. **해결 후**: 시나리오 1, 2, 3, 5 전체 재실행
3. **최종**: 10,000 VUs 규모 테스트 및 최종 성능 보고서 작성

---

**보고서 작성**: 2026-01-06
**테스트 도구**: k6 v0.52.0
**상태**: ❌ 실패 (대기열 활성화 차단 이슈)
**다음 리포트**: 활성화 이슈 해결 후 재테스트
